# 객체지향 프로그래밍
블록 형태의 모듈화된 프로그래밍
* 신뢰성, 추가/수정/삭제 용이, 재사용성, 유지보수성 <br>

현실의 객체가 갖는 속성과 기능이 **추상화 (abstraction)** 되어 *클래스*에 정의된다 <br>
*클래스*는 **구체화** 되어 *프로그램의 객체 (instance, object)* 가 된다 <br>

### 클래스
#### 멤버 변수 (상태, 속성)
* 전역 변수 이므로 자동 초기화
* **인스턴스 멤버 변수**
  * heap 에 객체 수 만큼 저장
  * 객체 생성 후 객체 이름으로 접근
  * 객체를 만들 때 마다 객체 별로 생성
  * Garbage Collector 에 의해 객체가 없어질 때 소멸
    * 프로그래머가 명시적으로 소멸시킬 수 없음 
* **클래스 멤버 변수**
  * **static** : 객체들 간에 공유 되는 유일한 값
    * Class Area 에 단 하나만 저장
    * 모든 객체가 공유
    * 객체 생성 없이 클래스 이름으로 사용가능
    * 멤버 필드, 메소드, 블록에 사용가능
  * 프로그램 종료 시 소멸
#### 멤버 메소드 (기능, 행위)
* **지역 변수**
  * 선언 된 라인이 실행될 때 생성 : thread 별로 생성된 stack 영역
  * 명시적 초기화 필요
  * 외부에서 접근 불가
  * 선언된 영역인 {} 를 벗어날 때 소멸
* **Variable arguments**
   * 메소드 선언 시 몇개의 인자가 들어올 지 예상할 수 없는 경우
   * ... 을 이용해 파라미터를 선언하면 호출 시 넘겨준 값의 개수에 따라 자동으로 배열 생성 및 초기화
```java
public void variableArgs(int... params) {}
```
* **Call by Value**
  * 메소드 호출 시 파라미터로 입력된 *값*을 **복사** 해서 전달
* **Method Overloading**
  * 동일한 기능을 수행하는 메소드의 *추가 작성* 
  * 중복 코드에 대한 효율적 관리 가능
  * 메소드의 이름은 동일하지만 파라미터의 개수 또는 순서, 타입이 달라야 함
  * 리턴 타입은 의미 없음

#### Constructor (생성자)
* 클래스 이름과 동일한 이름의 함수 (리턴 타입은 없음)
* 객체 생성 시에 호출
* **this()** : 생성자에서 다른 생성자 호출
* **super()** : 생성자에서 부모 생성자 호출


### 객체
클래스를 데이터 타입으로 메모리에 생성된 것 <br>
```java
Test t = new Test();
```
* heap 에 객체를 위한 공간 할당
* instance 변수 자동 초기화 | 명시적 초기화 (사용자가 지정한 값)
* 생성자 호출
* 참조값 반환 (주소값)
---
## Java is A P.I.E
* **Abstraction (추상화)** : 현실의 객체를 추상화 해서 클래스를 구성
* **Polymorphism (다형성)** : 하나의 객체를 여러가지 타입(형) 으로 참조
* **Inheritance (상속)** : 부모 클래스의 자산을 물려받아 자식을 정의함으로 코드의 재사용 가능
* **Encapsulation (데이터 은닉과 보호)** : 데이터를 외부에 직접 노출시키지 않고 메소드를 이용해 보호

## Inheritance
***is a* 관계** <br>
* 기존의 클래스의 자산을 자식 클래스에서 재사용하기 위한 것
  * 부모의 생성자와 초기화 블록은 상속하지 않음
    * 생상자는 상속받지 않지만 자식 인스턴스를 생성하면 자동 호출
    * 부모 객체가 먼저 생성 됨 으로서 부모 생성자가 먼저 호출
    * 부모 생성자가 매개 변수를 가지고 있으면 자동으로 호출되지 않음
* 부모의 코드를 변경하면 모든 자식들에게도 적용
* ***extends*** 키워드 사용

### Single Inheritance (단일 상속)
* Java 는 단일 상속만 지원
  * ***Interface*** 와 **포함관계 (*has a*)** 사용 가능
    * 포함 관계란 클래스에서 특성을 가져올 때 멤버 변수로 처리하는 것
* 부모 타입의 객체를 자식 타입으로 생성 시, **Override** 된 메소드를 제외하곤 쓸 수 없음
* 다중 상속의 경우 여러 클래스의 기능을 물려받을 수 있으나 관계가 복잡해짐

### Method Overriding
* 조상 클래스에 정의된 메소드를 자식 클래스에 적합하게 수정하는 것
  * **메소드 이름**이 같아야 한다
  * **매개 변수의 개수, 타입, 순서**가 같아야 한다
  * **리턴 타입**이 같아야 한다
  * **접근 제한자**는 부모 보다 범위가 넓거나 같아야 한다
  * 조상보다 더 큰 **예외**를 던질 수 없다
* Annotation : @Override
  * 컴파일러에게 해당 메소드는 Override 한 메소드임을 알려줌
  * 반드시 super class 에 선언되어있는 메소드여야 함

### Object Class
* 가장 최상위 클래스로 모든 클래스의 조상
* ***toString()*** : 객체를 문자열로 변경
  * String 클래스에서 주소값이 아닌 내용 반환으로 재정의함
* ***equals(Object obj)*** : 두 객체가 같은지를 비교
  * String 클래스에서 주소값이 아닌 내용 비교로 재정의함
  * 객체의 주소 비교는 == 활용
* ***hashCode()*** : 시스템에서 객체를 구별하기 위해 사용되는 정수 값
  * HashSet, HasMap 등 에서 객체의 동일성을 확인하기 위해 사용
  * equals 메소드를 재정의 할 때는 반드시 *hashCode* 도 재정의 할 것
 ---
 ## Encapsulation
 * 변수는 ***private*** 접근 제한자로 막을 수 있음
 * ***public*** 메소드를 통한 접근 통로 마련 : **setter / getter**

### Modifier (제한자)
* 클래스, 변수, 메소드 선언부에 사용되어 부가적인 의미 부여
* 하나의 대상에 여러 제한자를 조합 가능하나 **접근 제한자** 는 *하나* 만 사용 가능
* 종류
  * **접근 제한자** : *public, protected, default, private*
  * *static* : 클래스의 레벨 요소 설정
  * *final* : 요소를 더 이상 수정할 수 없음
    * *final class* : 상속 금지, Override 금지
    * *final method* : Override 금지
    * *final variable* : 상수화
  * *abstract* : 추상 메소드 및 추상 클래스
  * *synchronized* : 멀티스레드에서의 동기화 처리

#### Access Modifier (접근 제한자)
|제한자|같은 클래스|같은 패키지|다른 패키지의 자식 클래스|전체|
|:----:|:---------:|:---------:|:----------------------:|:--:|
|**public**|O|O|O|O|
|**protected**|O|O|O||
|**default**|O|O|||
|**private**|O||||

* **Method Override** 는 부모의 제한자 범위와 넓거나 같은 범위로만 사용 가능

### Singleton 디자인 패턴
* 객체의 생성 제한
  * 객체를 구별할 필요가 없는 경우 (stateless 객체)
  * 객체를 계속 생성 / 삭제 하는데 많은 비용이 들어 재사용이 유리한 경우
* 외부에서 생성자에 접근 금지
  * 생성자의 접근 제한자를 ***private*** 으로 설정
* 내부에서 직접 객체 생성
  * 멤버 변수이므로 ***private*** 설정
* 외부에서 *private member* 에 접근 가능한 **getter** 생성 (setter 는 불필요)
* 객체 없이 외부에서 접근할 수 있도록 **getter** 와 **변수** 에 ***static*** 추가
* 외부에서는 언제나 **getter** 를 통해 객체를 참조하므로 하나의 객체 재사용

---
## Polymorphism (다형성)
* 하나의 객체가 많은 형(타입)을 가질 수 있는 성질
* 조상 클래스의 타입으로 자식 클래스 객체를 참조 할 수 있음
* 다른 타입의 객체를 다루는 배열
  * Object 배열은 어떤 타입의 객체라도 다 저장할 수 있음
    * Collection API
* 매개변수의 다형성
  * Object 타입을 파라미터로 받는다는 것은 모든 객체를 처리한다는 것

### 참조형 객체의 형 변환
* 참조하는 변수의 타입에 따라 접근할 수 있는 내용이 제한됨
* 자식에서 부모로 : **묵시적 캐스팅**
* 부모에서 자식으로 : **명시적 캐스팅**
  * 부모 타입으로 생성된 객체는 캐스팅된 자식의 메소드를 쓸 수 없음
* ***instanceof*** 연산자로 실제 메모리에 있는 객체가 특정 클래스 타입인지 *boolean* 으로 리턴 
* 상속 관계에서 객체의 *멤버 변수*가 중복될 때
  * 참조 변수의 타입에 따라 연결이 달라짐
* 상속 관계에서 객체의 *메소드*가 중복될 때 (Override 되었을 때)
  * 무조건 자식 클래스의 메소드가 호출됨
